# Sample template of the internal builtin classes
#
# Copyright (c) 2017 Ron R Wills <ron.rwsoft@gmail.com>
#
# This file is part of Meat.
#
# Meat is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Meat is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Meat.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
#   Since we need gitgo to compile this file, the 'ᶲ' character found in all
#  the class names is to prevent collisions with the builtin in classes. Once
#  the cpp file is generated then the ᶲ characters are stripped out.
#   The generate cpp file is still not valid because all the hash values are
#  included in the name hashing...

Library include: {
#include <meat/utilities.h>

#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <cmath>

#ifdef TESTING
#include <testing.h>
#endif /* TESTING */
}

#==============================================================================
# Object Class

Object subClass: Objectᶲ body: {

  constructor {
    return new meat::Object(klass, properties);
  }

  class method == other {
    context return: [self is: other]
  }

  class method != other {
    context return: [self isNot: other]
  }

  class function is: other {
    return (self == other ? meat::True() : meat::False());
  }

  class function isNot: other {
    return (!(self == other) ? meat::True() : meat::False());
  }

  class method isObject {
    context return: [Boolean false]
  }

  class method isClass {
    context return: [Boolean true]
  }

  class method isNull {
    context return: [Boolean false]
  }

  class method type {
    context return: Class
  }

  method initialize {
  }

  method == other {
    context return: [self is: other]
  }

  method != other {
    context return: [self isNot: other]
  }

  function is: other {
    return (self == other ? meat::True() : meat::False());
  }

  function isNot: other {
    return (!(self == other) ? meat::True() : meat::False());
  }

  method isObject {
    context return: [Boolean true]
  }

  method isClass {
    context return: [Boolean false]
  }

  function type {
    return self->get_type();
  }

  function isType: type {
    return (self->is_type(type) ? meat::True() : meat::False());
  }

  method isNull {
    context return: [Boolean false]
  }

  function weak {
    return self.weak();
  }
}

#==============================================================================
# Class Class

Object subClass: Classᶲ body: {

  class function newObject {
    meat::Reference uplevel = CONTEXT(context).get_uplevel();

    // Create the new object and call the initialize method.
    meat::Reference new_object = CLASS(self).new_object();
    meat::Reference init_ctx = message(new_object, "initialize", context);
    execute(init_ctx);

    // We replace the self object to the new object.
    CONTEXT(uplevel).reset_self(new_object);

    return null;
  }

  class function subClass: name body: block {
    if (class_compiler != 0) {
      class_compiler(self, name->to_string(), block->to_string());
    }
    return null;
  }

  class function superClass {
    return CLASS(self).get_super();
  }

  class method initialize {
  }

  class function getName {
    return new meat::Text(CLASS(self).get_name());
  }
}

#==============================================================================
# Context Class

Object subClass: Contextᶲ body: {

  constructor {
    return new meat::Context(properties);
  }

  class method subClass: name body: def {
    Exception throw: "Cannot subclass an internal Context class"
  }

  class method newObject {
    Exception throw: "Cannot create a new internal Context object" \
      for: [context uplevel]
  }

  function messenger {
    return CONTEXT(self).get_uplevel();
  }

  function localVariables {
    return new meat::Object(CONTEXT(self).get_num_of_locals() - 4);
  }

  function getLocal: index {
    return CONTEXT(self).get_local(INTEGER(index));
  }

  function setLocal: index to: value {
    CONTEXT(self).set_local(INTEGER(index), value);
    return null;
  }

  function repeat: block {
    CONTEXT(block).set_messenger(context);

    for (;;) {
      BLOCK(block).set_break_trap();
      BLOCK(block).set_continue_trap();
      execute(block);

      if (BLOCK(block).break_called() or CONTEXT(block).is_done())
        break;

      BLOCK(block).reset();
    }
    BLOCK(block).reset();

    return null;
  }

  function return {
    CONTEXT(self).finish();
    return null;
  }

  function return: value {
    CONTEXT(self).set_result(value); // Set the return value
    CONTEXT(self).finish();          // Tell the context it's done.
    return null;
  }

  method break {
  }

  method continue {
  }
}

#==============================================================================
# BlockContext Class

Object subClass: BlockContextᶲ body: {

  function execute {
    BLOCK(self).set_messenger(context);
    execute(self);
    BLOCK(self).reset();

    return null;
  }

  function executeOnBreak: breakBlock {
    BLOCK(self).set_break_trap();
    BLOCK(self).set_messenger(context);
    execute(self);

    if (BLOCK(self).break_called()) {
      meat::Reference up_context = message(breakBlock, "execute", context);
      execute(up_context);
    }

    BLOCK(self).reset();

    return null;
  }

  function executeOnBreak: breakBlock onContinue: continueBlock {
    BLOCK(self).set_break_trap();
    BLOCK(self).set_continue_trap();
    BLOCK(self).set_messenger(context);
    execute(self);

    if (BLOCK(self).break_called()) {
      meat::Reference up_context = message(breakBlock, "execute", context);
      execute(up_context);
    } else if (BLOCK(self).continue_called()) {
      meat::Reference up_context = message(continueBlock, "execute", context);
      execute(up_context);
    }

    BLOCK(self).reset();

    return null;
  }

  function executeOnContinue: continueBlock {
    BLOCK(self).set_continue_trap();
    BLOCK(self).set_messenger(context);
    execute(self);

    if (BLOCK(self).continue_called()) {
      meat::Reference up_context = message(continueBlock, "execute", context);
      execute(up_context);
    }

    BLOCK(self).reset();

    return null;
  }

  function return {
    // We need to get the actual context to message the return method from.
    meat::Reference origin =
      ((meat::BlockContext &)(*self)).get_origin();

    meat::Reference up_context = message(origin, "return", context);
    execute(up_context);

    CONTEXT(self).finish(); // Tell the context it's done.

    return null;
  }

  function return: value {
    meat::Reference origin =
      ((meat::BlockContext &)(*self)).get_origin();

    meat::Reference up_context = message(origin, "return:", context);
    CONTEXT(up_context).set_param(0, value);
    execute(up_context);

    CONTEXT(self).finish(); // Tell the context it's done.

    return null;
  }

  function continue {
    BLOCK(self).c_continue();
    if (not BLOCK(self).continue_trap_set()) {
      meat::Reference init_ctx = BLOCK(self).get_origin();
      meat::Reference up_context = message(init_ctx, "continue", context);
      execute(up_context);
    }
    return null;
  }

  function break {
    BLOCK(self).c_break();
    if (not BLOCK(self).break_trap_set()) {
      meat::Reference init_ctx = BLOCK(self).get_origin();
      meat::Reference up_context = message(init_ctx, "break", context);
      execute(up_context);
    }
    return null;
  }
}

#==============================================================================
# Null Class
#
#  This class has only a single object to define null.

Object subClass: Nullᶲ body: {

  class property nullObject

  class method newObject {
    Exception throw: "Cannot create a new internal Null object" \
      for: [context messenger]
  }

  class method subClass: name body: block {
    Exception throw: "Cannot subclass an internal Null class" \
      for: [context messenger]
  }

  method object {
    context return: nullObject
  }

  method isNull {
    context return: [Boolean true]
  }
}

#==============================================================================
# Exception Class

Object subClass: Exceptionᶲ body: {

  property mesg
  property cntxt

  constructor {
    return new meat::Exception(klass, properties);
  }

  class function try: block {
    CONTEXT(block).set_messenger(context);

    try {
      execute(block);
    } catch (meat::Exception &err) {
    } catch (...) {
    }
    return null;
  }

  class function try: try_block catch: catch_block {
    CONTEXT(try_block).set_uplevel(context);
    CONTEXT(catch_block).set_uplevel(context);

    try {
      execute(try_block);
    } catch (std::exception &err) {
      execute(catch_block);
    }
    return null;
  }

  class function try: try_block catch: error do: catch_block {
    CONTEXT(try_block).set_uplevel(context);
    CONTEXT(catch_block).set_uplevel(context);

    try {
      execute(try_block);
    } catch (meat::Exception &err) {
      meat::Reference excp = new meat::Exception(err);
      CONTEXT(catch_block).set_local((meat::int32_t)(*error), excp);
      execute(catch_block);
    }

    return null;
  }

  class function throw {
    meat::Reference ctx = CONTEXT(context).get_messenger();
    throw meat::Exception(null, ctx);
  }

  class function throw: message {
    meat::Reference ctx = CONTEXT(context).get_messenger();
    throw meat::Exception(message, ctx);
  }

  class function throw: message for: ctx {
    throw meat::Exception(message, ctx);
  }

  method message {
    context return: mesg
  }

  method context {
    context return: cntxt
  }
}

#==============================================================================
# Numeric

Object subClass: Numericᶲ body: {

  class function cos: value {
    return
      new meat::Object((meat::float_t)std::cos(value->to_float()));
  }

  class function sin: value {
    return
      new meat::Object((meat::float_t)std::sin(value->to_float()));
  }

  class function tan: value {
    return
      new meat::Object((meat::float_t)std::tan(value->to_float()));
  }

  class function acos: value {
    return
      new meat::Object((meat::float_t)std::acos(value->to_float()));
  }

  class function asin: value {
    return
      new meat::Object((meat::float_t)std::asin(value->to_float()));
  }

  class function atan: value {
    return
      new meat::Object((meat::float_t)std::atan(value->to_float()));
  }

  class function atan2y: y x: x {
    return
      new meat::Object((meat::float_t)std::atan2(y->to_float(),
                                                   x->to_float()));
  }

  class function cosh: value {
    return
      new meat::Object((meat::float_t)std::cosh(value->to_float()));
  }

  class function sinh: value {
    return
      new meat::Object((meat::float_t)std::sinh(value->to_float()));
  }

  class function tanh: value {
    return
      new meat::Object((meat::float_t)std::tanh(value->to_float()));
  }

  class function exp: value {
    meat::float_t answer = (meat::float_t)std::exp(value->to_float());

    if (answer == HUGE_VAL) throw meat::Exception("exp range error");

    return new meat::Object(answer);
  }

  class function log: value {
    if ((value->to_float()) <= 0.0)
      throw meat::Exception("Log parameter out of range");

    return
      new meat::Object((meat::float_t)std::log(value->to_float()));
  }

  class function log10: value {
    if ((value->to_float()) <= 0.0)
      throw meat::Exception("Log10 parameter out of range");

    return
      new meat::Object((meat::float_t)std::log10(value->to_float()));
  }

  class function sqrt: value {
    if ((value->to_float()) < 0.0)
      throw meat::Exception("Square root parameter out of range");

    return
      new meat::Object((meat::float_t)std::sqrt(value->to_float()));
  }

  method + other {
    Exception throw: "Method + undefined"
  }

  method - other {
    Exception throw: "Method - undefined"
  }

  method * other {
    Exception throw: "Method * undefined"
  }

  method / other {
    Exception throw: "Method / undefined"
  }

  method % other {
    Exception throw: "Method % undefined"
  }

  method ^ other {
    Exception throw: "Method ^ undefined"
  }

  method == other {
    Exception throw: "Method == undefined"
  }

  method != other {
    Exception throw: "Method != undefined"
  }

  method < other {
    Exception throw: "Method < undefined"
  }

  method <= other {
    Exception throw: "Method <= undefined"
  }

  method > other {
    Exception throw: "Method > undefined"
  }

  method >= other {
    Exception throw: "Method >= undefined"
  }

  method neg {
    Exception throw: "Method neg undefined"
  }

  method abs {
    Exception throw: "Method abs undefined"
  }

  method asText {
    Exception throw: "Unable to convert numeric value to Text"
  }
}

#==============================================================================
# Integer

Numeric subClass: Integerᶲ body: {

  function + other {
    return new meat::Object(self->to_int() + other->to_int());
  }

  function - other {
    return new meat::Object(self->to_int() - other->to_int());
  }

  function * other {
    return new meat::Object(self->to_int() * other->to_int());
  }

  function / other {
    return new meat::Object(self->to_int() / other->to_int());
  }

  function % other {
    return new meat::Object(self->to_int() % other->to_int());
  }

  function ^ other {
    return new meat::Object((meat::float_t)std::pow(self->to_float(),
                other->to_float()));
  }

  function == other {
    try {
      if (self->to_int() == other->to_int())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function != other {
    try {
      if (self->to_int() != other->to_int())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function < other {
    try {
      if (self->to_int() < other->to_int())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function <= other {
    try {
      if (self->to_int() <= other->to_int())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function > other {
    try {
      if (self->to_int() > other->to_int())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function >= other {
    try {
      if (self->to_int() >= other->to_int())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function neg {
    return new meat::Object(-self->to_int());
  }

  function abs {
    return new meat::Object(std::abs(self->to_int()));
  }

  function or: other {
    return new meat::Object(self->to_int() |
      other->to_int());
  }

  function and: other {
    return new meat::Object(self->to_int() &
      other->to_int());
  }

  function xor: other {
    return new meat::Object(self->to_int() ^
      other->to_int());
  }

  function rshift {
    return new meat::Object(self->to_int() >> 1);
  }

  function rshift: amount {
    return new meat::Object(self->to_int() >>
      (meat::int32_t)(*amount));
  }

  function lshift {
    return new meat::Object(self->to_int() << 1);
  }

  function lshift: amount {
    return new meat::Object(self->to_int() <<
      (meat::int32_t)(*amount));
  }

  function timesDo: block {
    meat::int32_t limit = self->to_int();
    meat::uint8_t start_ip = CONTEXT(block).get_ip();

    for (meat::int32_t c = 0; c < limit; c++) {
      meat::execute(block);
      CONTEXT(block).set_ip(start_ip);
    }

    return null;
  }

  function asText {
    std::stringstream result;
    result << (unsigned int)(self->to_int());
    return new meat::Object(result.str().c_str());
  }
}

#==============================================================================
# Number Class

Numeric subClass: Numberᶲ body: {

  function + other {
    return new meat::Object(self->to_float() +
                             other->to_float());
  }

  function - other {
    return new meat::Object(self->to_float() -
                             other->to_float());
  }

  function * other {
    return new meat::Object(self->to_float() *
                             other->to_float());
  }

  function / other {
    return new meat::Object(self->to_float() /
                             other->to_float());
  }

  function % other {
    return new meat::Object(std::fmod(self->to_float(),
                                       other->to_float()));
  }

  function ^ other {
    return new meat::Object((meat::float_t)std::pow(self->to_float(),
                             other->to_float()));
  }

  function == other {
    try {
      if (self->to_float() == other->to_float())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function != other {
    try {
      if (self->to_float() != other->to_float())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function < other {
    try {
      if (self->to_float() < other->to_float())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function <= other {
    try {
      if (self->to_float() <= other->to_float())
        return meat::True();
    } catch (...) {}
    return meat::False();
  }

  function > other {
    try {
      if (self->to_float() > other->to_float())
        return meat::True();
    } catch (...) {}
    return null;
  }

  function >= other {
    try {
      if (self->to_float() >= other->to_float())
        return meat::True();
    } catch (...) {}
    return null;
  }

  function neg {
    return new meat::Object(-self->to_float());
  }

  function abs {
    return new meat::Object(std::abs(self->to_float()));
  }

  function asText {
    std::stringstream result;
    result << (double)(self->to_float());
    return new meat::Object(result.str().c_str());
  }
}

#==============================================================================
# Boolean Class

Object subClass: Booleanᶲ body: {

  class property trueObject
  class property falseObject

  class method true {
    context return: trueObject
  }

  class method false {
    context return: falseObject
  }

  function isTrue: block {
    if (self == trueObject) execute(block);
    return null;
  }

  function isTrue: true_block else: else_block {
    if (self == meat::True()) {
      execute(true_block);
    } else {
      execute(else_block);
    }
    return null;
  }

  function isFalse: block {
    if (self == falseObject) execute(block);
    return null;
  }

  function isFalse: true_block else: else_block {
    if (self == meat::False()) {
      execute(true_block);
    } else {
      execute(else_block);
    }
    return null;
  }

  method not {
    [self == trueObject] isTrue: {
      context return: falseObject
    } else: {
      context return: trueObject
    }
  }

  function or: other {
    if (self == meat::True() or other == meat::True())
      return meat::True();
    else
      return meat::False();
  }

  function xor: other {
    if (self == meat::True() xor other == meat::True())
      return meat::True();
    else
      return meat::False();
  }

  function and: other {
    if (self == meat::True() and other == meat::True())
      return meat::True();
    else
      return meat::False();
  }

  method asText {
    [self == trueObject] isTrue: {
      context return: "true"
    } else: {
      context return: "false"
    }
  }
}

#==============================================================================
# Text Class

Object subClass: Textᶲ body: {

  constructor {
    new meat::Text(klass, properties);
  }

  function isEmpty {
    return (TEXT(self).empty() ? meat::True() : meat::False());
  }

  function length {
    unsigned int len = 0;
    meat::Text &str = TEXT(self);

    // Count UTF-8 characters not bytes.
    for (unsigned int i = 0; str[i]; ++i)
      if ((str[i] & 0xC0) != 0x80) len++;

    return new meat::Value((meat::int32_t)len);
  }

  function getCharAt: index {
    return new meat::Text(&(TEXT(self)[INTEGER(index) - 1]));
  }

  function get: start to: end {
    meat::Reference self = CONTEXT(context).get_self();
    meat::Reference start = CONTEXT(context).get_param(0);
    meat::Reference end = CONTEXT(context).get_param(1);

    meat::int32_t start_pos = INTEGER(start) - 1;
    meat::int32_t len = INTEGER(end) - start_pos;

    meat::Text *new_string = new meat::Text();
    (*new_string) += TEXT(self).substr(start_pos, len);
    return new_string;
  }

  function == other {
    return (TEXT(self).compare(TEXT(other)) == 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function != other {
    return (TEXT(self).compare(TEXT(other)) != 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function < other {
    return (TEXT(self).compare(TEXT(other)) < 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function <= other {
    return (TEXT(self).compare(TEXT(other)) <= 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function > other {
    return (TEXT(self).compare(TEXT(other)) > 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function >= other {
    return (TEXT(self).compare(TEXT(other)) >= 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function + other {
    return new meat::Text(TEXT(self) +  TEXT(other));
  }

  function * count {
    meat::int32_t cnt_value = INTEGER(count);
    meat::Text *result = new meat::Text();

    for (int c = 0; c < cnt_value; c++)
      (*result) += TEXT(self);

    return result;
  }

  method asText {
    context return: self
  }
}

#==============================================================================
# List Class

Object subClass: Listᶲ body: {

  constructor {
    return new meat::List(klass, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function get: index {
    try {
      return LIST(self).at(INTEGER(index) - 1);
    } catch (std::out_of_range &err) {
      throw meat::Exception("List index out of Range", context);
    }
    return null;
  }

  function set: index to: value {
    try {
      LIST(self).at(INTEGER(index) - 1) = value;
    } catch (std::out_of_range &err) {
      throw meat::Exception("Index out of Range", context);
    }
    return null;
  }

  function at: index insert: value {
    LIST(self).insert(LIST(self).begin() + (INTEGER(index) - 1), value);
    return null;
  }

  function remove: value {
    meat::List::iterator it = LIST(self).begin();
    while (it != LIST(self).end()) {
      if (*it == value)
        LIST(self).erase(it);
      it++;
    }

    return null;
  }

  function removeAt: index {
    LIST(self).erase(LIST(self).begin() + (INTEGER(index) - 1));
    return null;
  }

  function removeFrom: start to: end {
    LIST(self).erase(LIST(self).begin() + (INTEGER(start) - 1),
                     LIST(self).begin() + (INTEGER(end) - 1));
    return null;
  }

  function append: value {
    if (other->is_type(meat::Class::resolve("List"))) {
      LIST(self).insert(LIST(self).end(),
                        LIST(value).begin(),
                        LIST(value).end());
    } else {
      LIST(self).push_back(value);
    }

    return null;
  }

  function push: value {
    ((meat::List &)(*self)).push_back(value);
    return null;
  }

  function pop {
    LIST(self).pop_back();
    return null;
  }

  function isEmpty {
    return (LIST(self).empty() ? meat::True() : meat::False());
  }

  function swap: first with: second {
    try {
      meat::Reference temp = ((meat::List &)(*self)).at((int32_t)(*first) - 1);
      ((meat::List &)(*self)).at((int32_t)(*first) - 1) =
        ((meat::List &)(*self)).at((int32_t)(*second) - 1);
      ((meat::List &)(*self)).at((int32_t)(*second) - 1) = temp;
    } catch (std::out_of_range &err) {
      throw meat::Exception("Index out of Range", context);
    }

    return null;
  }

  function last {
    return LIST(self).back();
  }

  function clear {
    LIST(self).clear();
    return null;
  }

  function items {
    return new meat::Value((int32_t)(LIST(self).size()));
  }

  function forEach: item do: block {
    meat::uint16_t start_ip = CONTEXT(block).get_ip();
    meat::uint8_t local_id = (int32_t)(*item);

    CONTEXT(block).set_uplevel(context);

    meat::List::iterator it = ((meat::List &)(*self)).begin();
    for (; it != ((meat::List &)(*self)).end(); it++) {
      CONTEXT(block).set_local(local_id, *it);
      Reference result = execute(block);
      CONTEXT(block).set_ip(start_ip);
      CONTEXT(block).unfinish();

      if (result == "break") break;
    }

    return null;
  }

  function copy {
    Reference new_list = meat::List();
    LIST(new_list) = LIST(self);
    return new_list;
  }
}

#==============================================================================
# Set Class

Object subClass: Setᶲ body: {

  constructor {
    return new meat::Set(cls, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function remove: value {
    meat::List::iterator it = ((meat::List &)(*self)).begin();
    while (it != ((meat::List &)(*self)).end()) {
      if (*it == value)
        ((meat::List &)(*self)).erase(it);
      it++;
    }

    return null;
  }

  function insert: value {
    SET(self).insert(value);
    return null;
  }

  function hasEntry: value {
    return (SET(self).find(value) != SET(self).end()
            ? meat::True() : meat::False());
  }

  function isEmpty {
    return (SET(self).empty() ? meat::True() : meat::False());
  }

  function swap: other {
    SET(self).swap(SET(other));
    return null;
  }

  function clear {
    SET(self).clear();
    return null;
  }

  function entries {
    return new meat::Value(SET(size).size());
  }

  function forEach: item do: block {
    meat::uint8_t local_id = INTEGER(item);

    CONTEXT(block).set_messenger(context);

    meat::List::iterator it = SET(self).begin();
    for (; it != SET(self).end(); it++) {
      BLOCK(block).set_local(local_id, *it);
      execute(block);

      if (BLOCK(block).break_called() or CONTEXT(block).is_done())
        break;

      BLOCK(block).reset();
    }
    BLOCK(block).reset();

    return null;
  }

  function copy {
    Reference new_set = meat::Set();
    SET(new_set) = SET(self);
    return new_set;
  }
}


#==============================================================================
# Index Class

Object subClass: Indexᶲ body: {

  constructor {
    return new meat::Index(cls, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function get: key {
    meat::Index::iterator it = INDEX(self).find(key);
    if (it == INDEX(self).end())
      throw meat::Exception("Invalid key in index");

    return *it;
  }

  function set: key to: value {
    INDEX(self)[key] = value;
    return null;
  }

  function has: key {
    if (INDEX(*self).find(key) != INDEX(self).end())
      return meat::True();
    return meat::False();
  }

  function remove: key {
    INDEX(self).erase(key);
    return null;
  }

  function entries {
    int32_t size = INDEX(*self).size();
    return new meat::Value(size);
  }

  function isEmpty {
    return (INDEX(self).empty() ? meat::True() : meat::False());
  }

  function copy {
    meat::Index *result = new meat::Index();
    *result = INDEX(self);
    return result;
  }
}

#==============================================================================
# Application Class

Object subClass: Applicationᶲ body: {

  class function parameters {
    return new meat::Object((meat::int32_t)arg_count());
  }

  class function parameter: index {
    meat::int32_t idx = (int32_t)(*index);

    if (idx > arg_count() or idx <= 0)
      throw meat::Exception("Parameter index out of range");

    const char **argv = args();
    return new meat::Object(argv[idx - 1]);
  }

  class function getEnviron: key {
#if defined(__WIN32__)
#  error("TODO Environment access")
#elif defined(__linux__)
    char *value = getenv(key->to_string());
    if (value != (char *)0)
      return new meat::Object(value);
    else
      return new meat::Object("");
#else
#  error("Don't know how to read the system environment")
#endif
  }

  class method entry {
    Exception throw: "Application class method entry must be overridden"
  }

  method entry {
    Exception throw: "Application method entry must be overridden"
  }
}

#==============================================================================
# Library Class

Object subClass: Libraryᶲ body: {

  class property newLibrary

  property cppIncludes
  property applicationClass
  property imports
  property classes

  class function import: filename {
#ifdef DEBUG
    std::cout << "DEBUG: Importing library " << filename->to_string()
              << std::endl;
#endif /* DEBUG */

    if (meat::data::compiler_import != 0)
      meat::data::compiler_import(filename->to_string());
    else {
      meat::data::Library::import(filename->to_string());
    }

    return null;
  }

  #class function include: cpp_includes {
  # if (meat::data::compiler_import != 0)
  #   meat::data::Library::include(cpp_includes->to_string());
  # else
  #   throw Exception("Method Library include is only with the compiler");
  #
  # return null;
  #}

  class method include: includes {
    [newLibrary isNull] isFalse: {
      cppIncludes = includes
    } else: {
      Exception throw: "Library method include: can only be used with Grinder"
    }
  }

  class function setApplication: class_name {
    ((meat::data::Library &)(*self)).set_application(class_name->to_string());
  }
}
