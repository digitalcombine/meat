# Sample template of the internal builtin classes
#
# Copyright (c) 2017 Ron R Wills <ron.rwsoft@gmail.com>
#
# This file is part of Meat.
#
# Meat is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Meat is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Meat.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
#   Since we need gitgo to compile this file, the 'ᶲ' character found in all
#  the class names is to prevent collisions with the builtin in classes. Once
#  the cpp file is generated then the ᶲ characters are stripped out.
#   The generate cpp file is still not valid because all the hash values are
#  included in the name hashing...

Library include: {
#include <meat/utilities.h>

#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>

#ifdef TESTING
#include <testing.h>
#endif /* TESTING */
}

#==============================================================================
# Object Class

Object subClass: Objectᶲ as: {

  constructor {
    return new meat::Object(klass, properties);
  }

  class method == other {
    context return: [self is: other]
  }

  class method <> other {
    context return: [self isNot: other]
  }

  class function is: other {
    return (self == other ? meat::BTrue() : meat::BFalse());
  }

  class function isNot: other {
    return (!(self == other) ? meat::BTrue() : meat::BFalse());
  }

  class method isObject {
    context return: [Boolean false]
  }

  class method isClass {
    context return: [Boolean true]
  }

  class method isNull {
    context return: [Boolean false]
  }

  class method type {
    context return: Class
  }

  method initialize {
  }

	method cleanUp {
	}

  method == other {
    context return: [self is: other]
  }

  method <> other {
    context return: [self isNot: other]
  }

  function is: other {
    return meat::Boolean(self == other);
  }

  function isNot: other {
    return meat::Boolean(!(self == other));
  }

  method isObject {
    context return: [Boolean true]
  }

  method isClass {
    context return: [Boolean false]
  }

  function type {
    return self->get_type();
  }

  function isType: type {
    return meat::Boolean(self->is_type(type));
  }

  method isNull {
    context return: [Boolean false]
  }

  function weak {
    return self.weak();
  }
}

#==============================================================================
# Class Class

Object subClass: Classᶲ as: {

  class function newObject {
    meat::Reference messenger = 
      meat::cast<meat::Context>(context).get_messenger();

    // Create the new object and call the initialize method.
    meat::Reference new_object = CLASS(self).new_object();
    meat::Reference init_ctx = message(new_object, "initialize", context);
    execute(init_ctx);

    // We replace the self object to the new object.
    meat::cast<meat::Context>(messenger).reset_self(new_object);

    return null;
  }

  class function subClass: name as: block {
    if (class_compiler != 0) {
      class_compiler(self, name->to_string(), block->to_string());
    } else {
      throw meat::Exception("No compiler implementation is loaded.");
    }

    return null;
  }

  class function superClass {
    return meat::cast<meat::Class>(self).get_super();
  }

  class method initialize {
  }

  class function getName {
    return new meat::Text(meat::cast<meat::Class>(self).get_name());
  }
}

#==============================================================================
# Context Class

Object subClass: Contextᶲ as: {

  constructor {
    return new meat::Context(properties);
  }

  class method subClass: name as: def {
    Exception throw: "Cannot subclass an internal Context class"
  }

  class method newObject {
    Exception throw: "Cannot create a new internal Context object" \
      for: [context uplevel]
  }

  function messenger {
    return meat::cast<meat::Context>(self).get_messenger();
  }

  function localVariables {
    return new meat::Object(meat::cast<meat::Context>(self).get_num_of_locals() - 4);
  }

  function getLocal: index {
    return meat::cast<meat::Context>(self).get_local(INTEGER(index));
  }

  function setLocal: index to: value {
    meat::cast<meat::Context>(self).set_local(INTEGER(index), value);
    return null;
  }

  function repeat: block {
    meat::cast<meat::Context>(block).set_messenger(context);

    for (;;) {
      meat::cast<meat::BlockContext>(block).set_break_trap();
      meat::cast<meat::BlockContext>(block).set_continue_trap();
      execute(block);

      if (meat::cast<meat::BlockContext>(block).break_called() or meat::cast<meat::Context>(block).is_done())
        break;

      meat::cast<meat::BlockContext>(block).reset();
    }
    meat::cast<meat::BlockContext>(block).reset();

    return null;
  }

  function return {
    meat::cast<meat::Context>(self).finish();
    return null;
  }

  function return: value {
    meat::cast<meat::Context>(self).set_result(value); // Set the return value
    meat::cast<meat::Context>(self).finish();          // Tell the context it's done.
    return null;
  }

  method break {
  }

  method continue {
  }
}

#==============================================================================
# BlockContext Class

Object subClass: BlockContextᶲ as: {

  function execute {
    meat::cast<meat::BlockContext>(self).set_messenger(context);
    execute(self);
    meat::cast<meat::BlockContext>(self).reset();

    return null;
  }

  function executeOnBreak: breakBlock {
    meat::cast<meat::BlockContext>(self).set_break_trap();
    meat::cast<meat::BlockContext>(self).set_messenger(context);
    execute(self);

    if (meat::cast<meat::BlockContext>(self).break_called()) {
      meat::Reference up_context = message(breakBlock, "execute", context);
      execute(up_context);
    }

    meat::cast<meat::BlockContext>(self).reset();

    return null;
  }

  function executeOnBreak: breakBlock onContinue: continueBlock {
    meat::cast<meat::BlockContext>(self).set_break_trap();
    meat::cast<meat::BlockContext>(self).set_continue_trap();
    meat::cast<meat::BlockContext>(self).set_messenger(context);
    execute(self);

    if (meat::cast<meat::BlockContext>(self).break_called()) {
      meat::Reference up_context = message(breakBlock, "execute", context);
      execute(up_context);
    } else if (meat::cast<meat::BlockContext>(self).continue_called()) {
      meat::Reference up_context = message(continueBlock, "execute", context);
      execute(up_context);
    }

    meat::cast<meat::BlockContext>(self).reset();

    return null;
  }

  function executeOnContinue: continueBlock {
    meat::cast<meat::BlockContext>(self).set_continue_trap();
    meat::cast<meat::BlockContext>(self).set_messenger(context);
    execute(self);

    if (meat::cast<meat::BlockContext>(self).continue_called()) {
      meat::Reference up_context = message(continueBlock, "execute", context);
      execute(up_context);
    }

    meat::cast<meat::BlockContext>(self).reset();

    return null;
  }

  function return {
    // We need to get the actual context to message the return method from.
    meat::Reference origin = meat::cast<meat::BlockContext>(self).get_origin();
    meat::Reference up_context = message(origin, "return", context);
    execute(up_context);

    meat::cast<meat::Context>(self).finish(); // Tell the context it's done.

    return null;
  }

  function return: value {
    meat::Reference origin = meat::cast<meat::BlockContext>(self).get_origin();
    meat::Reference up_context = message(origin, "return:", context);
    meat::cast<meat::Context>(up_context).set_param(0, value);
    execute(up_context);

    meat::cast<meat::Context>(self).finish(); // Tell the context it's done.

    return null;
  }

  function continue {
    meat::cast<meat::BlockContext>(self).c_continue();
    if (not meat::cast<meat::BlockContext>(self).continue_trap_set()) {
      meat::Reference init_ctx = meat::cast<meat::BlockContext>(self).get_origin();
      meat::Reference up_context = message(init_ctx, "continue", context);
      execute(up_context);
    }
    return null;
  }

  function break {
    meat::cast<meat::BlockContext>(self).c_break();
    if (not meat::cast<meat::BlockContext>(self).break_trap_set()) {
      meat::Reference init_ctx = meat::cast<meat::BlockContext>(self).get_origin();
      meat::Reference up_context = message(init_ctx, "break", context);
      execute(up_context);
    }
    return null;
  }
}

#==============================================================================
# Null Class
#
#  This class has only a single object to define null.

Object subClass: Nullᶲ as: {

  class property nullObject

  class method newObject {
    Exception throw: "Cannot create a new internal Null object" \
      for: [context messenger]
  }

  class method subClass: name as: block {
    Exception throw: "Cannot subclass an internal Null class" \
      for: [context messenger]
  }

  method object {
    context return: nullObject
  }

  method isNull {
    context return: [Boolean true]
  }
}

#==============================================================================
# Exception Class

Object subClass: Exceptionᶲ as: {

  property mesg
  property cntxt

  constructor {
    return new meat::Exception(klass, properties);
  }

  class function try: block {
    meat::cast<meat::Context>(block).set_messenger(context);

    try {
  		execute(block);
    } catch (meat::Exception &err) {
    } catch (...) {
    }

		meat::cast<meat::BlockContext>(block).reset();
    return null;
  }

  class function try: try_block catch: catch_block {
    meat::cast<meat::Context>(try_block).set_messenger(context);
    meat::cast<meat::Context>(catch_block).set_messenger(context);

    try {
      execute(try_block);
    } catch (std::exception &err) {
      execute(catch_block);
    }

		meat::cast<meat::BlockContext>(try_block).reset();
		meat::cast<meat::BlockContext>(catch_block).reset();

    return null;
  }

  class function try: try_block catch: error do: catch_block {
    meat::cast<meat::Context>(try_block).set_messenger(context);
    meat::cast<meat::Context>(catch_block).set_messenger(context);

    try {
      execute(try_block);
    } catch (meat::Exception &err) {
      meat::Reference excp = new meat::Exception(err);
      meat::cast<meat::Context>(catch_block).set_local((meat::int32_t)(*error), excp);
      execute(catch_block);
    }

		meat::cast<meat::BlockContext>(try_block).reset();
		meat::cast<meat::BlockContext>(catch_block).reset();

    return null;
  }

  class function throw {
    meat::Reference ctx = meat::cast<meat::Context>(context).get_messenger();
    throw meat::Exception(null, ctx);
  }

  class function throw: message {
    meat::Reference ctx = meat::cast<meat::Context>(context).get_messenger();
    throw meat::Exception(message, ctx);
  }

  class function throw: message for: ctx {
    throw meat::Exception(message, ctx);
  }

  method message {
    context return: mesg
  }

  method context {
    context return: cntxt
  }
}

#==============================================================================
# Boolean Class

Object subClass: Booleanᶲ as: {

  class property trueObject
  class property falseObject

  class method true {
    context return: trueObject
  }

  class method false {
    context return: falseObject
  }

  function isTrue: block {
    if (self == trueObject) {
		  meat::cast<meat::BlockContext>(block).set_messenger(context);
      execute(block);
			meat::cast<meat::BlockContext>(block).reset();
	  }
    return null;
  }

  function isTrue: trueBlock else: elseBlock {
    if (self == trueObject) {
		  meat::cast<meat::BlockContext>(trueBlock).set_messenger(context);
      execute(trueBlock);
			meat::cast<meat::BlockContext>(trueBlock).reset();
    } else {
		  meat::cast<meat::BlockContext>(elseBlock).set_messenger(context);
      execute(elseBlock);
			meat::cast<meat::BlockContext>(elseBlock).reset();
    }
    return null;
  }

  function isFalse: block {
    if (self == falseObject) {
      meat::cast<meat::BlockContext>(block).set_messenger(context);
			execute(block);
			meat::cast<meat::BlockContext>(block).reset();
	  }
    return null;
  }

  function isFalse: falseBlock else: elseBlock {
    if (self == falseObject) {
		  meat::cast<meat::BlockContext>(falseBlock).set_messenger(context);
      execute(falseBlock);
			meat::cast<meat::BlockContext>(falseBlock).reset();
    } else {
		  meat::cast<meat::BlockContext>(elseBlock).set_messenger(context);
      execute(elseBlock);
			meat::cast<meat::BlockContext>(elseBlock).reset();
    }
    return null;
  }

  method not {
    [self == trueObject] isTrue: {
      context return: falseObject
    } else: {
      context return: trueObject
    }
  }

  function or: other {
	  return ((self == trueObject or other == trueObject) ?
            trueObject : falseObject);
  }

  function xor: other {
	  return ((self == trueObject xor other == trueObject) ?
            trueObject : falseObject);
  }

  function and: other {
    return ((self == trueObject and other == trueObject) ?
            trueObject : falseObject);
  }

  method asText {
    [self == trueObject] isTrue: {
      context return: "true"
    } else: {
      context return: "false"
    }
  }
}

#==============================================================================
# Numeric

Object subClass: Numericᶲ as: {

  class method minValue {
    Exception throw: "Numeric value has no minimum value"
  }

  class method maxValue {
    Exception throw: "Numeric value has no minimum value"
  }

  method + other {
    Exception throw: "Method + undefined"
  }

  method - other {
    Exception throw: "Method - undefined"
  }

  method * other {
    Exception throw: "Method * undefined"
  }

  method / other {
    Exception throw: "Method / undefined"
  }

  method % other {
    Exception throw: "Method % undefined"
  }

  method ^ other {
    Exception throw: "Method ^ undefined"
  }

  method == other {
    Exception throw: "Method == undefined"
  }

  method <> other {
    Exception throw: "Method <> undefined"
  }

  method < other {
    Exception throw: "Method < undefined"
  }

  method <= other {
    Exception throw: "Method <= undefined"
  }

  method > other {
    Exception throw: "Method > undefined"
  }

  method >= other {
    Exception throw: "Method >= undefined"
  }

  method negative {
    Exception throw: "Method negative undefined"
  }

  method absolute {
    Exception throw: "Method absolute undefined"
  }

  method asText {
    Exception throw: "Unable to convert numeric value to Text"
  }
}

#==============================================================================
# Integer

Numeric subClass: Integerᶲ as: {

	constructor {
	  return new meat::Value(klass, properties);
	}

  class function minValue {
    return new meat::Value(-2147483647-1);
  }

  class function maxValue {
    return new meat::Value(2147483647);
  }

  function + other {
    meat::uint32_t res;
    bool overflow = __builtin_add_overflow(INTEGER(self), 
                                           INTEGER(other),
                                           &res);
    if (overflow)
      throw meat::Exception("Addition overflow");
    return new meat::Value(res);
  }

  function - other {
    return new meat::Value(INTEGER(self) - INTEGER(other));
  }

  function * other {
    return new meat::Value(INTEGER(self) * INTEGER(other));
  }

  function / other {
    return new meat::Value(INTEGER(self) / INTEGER(other));
  }

  function % other {
    return new meat::Value(INTEGER(self) % INTEGER(other));
  }

  function ^ other {
    return new meat::Value((meat::float_t)std::pow(FLOAT(self),
                                                   FLOAT(other)));
  }

  function == other {
    try {
      if (INTEGER(self) == INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <> other {
    try {
      if (INTEGER(self) != INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function < other {
    try {
      if (INTEGER(self) < INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <= other {
    try {
      if (INTEGER(self) <= INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function > other {
    try {
      if (INTEGER(self) > INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function >= other {
    try {
      if (INTEGER(self) >= INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function negative {
    return new meat::Value(-INTEGER(self));
  }

  function absolute {
    return new meat::Value(std::abs(INTEGER(self)));
  }

  function or: other {
    return new meat::Value(INTEGER(self) | INTEGER(other));
  }

  function and: other {
    return new meat::Value(INTEGER(self) & INTEGER(other));
  }

  function xor: other {
    return new meat::Value(INTEGER(self) ^ INTEGER(other));
  }

  function rshift {
    return new meat::Value(INTEGER(self) >> 1);
  }

  function rshift: amount {
    return new meat::Value(INTEGER(self) >> INTEGER(amount));
  }

  function lshift {
    return new meat::Value(INTEGER(self) << 1);
  }

  function lshift: amount {
    return new meat::Value(INTEGER(self) << INTEGER(amount));
  }

  function timesDo: block {
    meat::int32_t limit = INTEGER(self);

		meat::cast<meat::BlockContext>(block).set_messenger(context);
    for (meat::int32_t c = 0; c < limit; c++) {
      meat::execute(block);
      meat::cast<meat::BlockContext>(block).reset();
    }

    return null;
  }

  function asText {
    std::stringstream result;
    result << INTEGER(self);
    return new meat::Text(result.str());
  }
}

#==============================================================================
# Number Class

Numeric subClass: Numberᶲ as: {

	constructor {
	  return new meat::Value(klass, properties);
	}

  function + other {
    return new meat::Value(FLOAT(self) + FLOAT(other));
  }

  function - other {
	  return new meat::Value(FLOAT(self) - FLOAT(other));
  }

  function * other {
	  return new meat::Value(FLOAT(self) * FLOAT(other));
  }

  function / other {
	  if (FLOAT(other) == 0.0)
      throw meat::Exception("Divide by zero");

  	return new meat::Value(FLOAT(self) / FLOAT(other));
  }

  function % other {
    return new meat::Value(std::fmod(FLOAT(self), FLOAT(other)));
  }

  function ^ other {
    return new meat::Value((meat::float_t)std::pow(FLOAT(self),
                                                   FLOAT(other)));
  }

  function == other {
    try {
      if (FLOAT(self) == FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <> other {
    try {
      if (FLOAT(self) != FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function < other {
    try {
      if (FLOAT(self) < FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <= other {
    try {
      if (FLOAT(self) <= FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function > other {
    try {
      if (FLOAT(self) > FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function >= other {
    try {
      if (FLOAT(self) >= FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function negative {
    return new meat::Value(-FLOAT(self));
  }

  function absolute {
    return new meat::Value(std::abs(FLOAT(self)));
  }

  function asText {
    std::stringstream result;
    result << (double)FLOAT(self);
    return new meat::Text(result.str());
  }
}

#==============================================================================
# Text Class

Object subClass: Textᶲ as: {

  constructor {
    new meat::Text(klass, properties);
  }

  function isEmpty {
    return (TEXT(self).empty() ? meat::True() : meat::False());
  }

  function length {
    unsigned int len = 0;
    meat::Text &str = TEXT(self);

    // Count UTF-8 characters not bytes.
    for (unsigned int i = 0; str[i]; ++i)
      if ((str[i] & 0xC0) != 0x80) len++;

    return new meat::Value((meat::int32_t)len);
  }

  function getCharAt: index {
    return new meat::Text(&(TEXT(self)[INTEGER(index) - 1]));
  }

  function get: start to: end {    
    meat::int32_t start_pos = INTEGER(start) - 1;
    meat::int32_t len = INTEGER(end) - start_pos;

    meat::Text *new_string = new meat::Text();
    (*new_string) += TEXT(self).substr(start_pos, len);
    return new_string;
  }

  function == other {
    return (TEXT(self).compare(TEXT(other)) == 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function <> other {
    return (TEXT(self).compare(TEXT(other)) != 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function < other {
    return (TEXT(self).compare(TEXT(other)) < 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function <= other {
    return (TEXT(self).compare(TEXT(other)) <= 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function > other {
    return (TEXT(self).compare(TEXT(other)) > 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function >= other {
    return (TEXT(self).compare(TEXT(other)) >= 0 ?
      meat::BTrue() : meat::BFalse());
  }

  function + other {
    return new meat::Text(TEXT(self) +  TEXT(other));
  }

  function * count {
    meat::int32_t cnt_value = INTEGER(count);
    meat::Text *result = new meat::Text();

    for (int c = 0; c < cnt_value; c++)
      (*result) += TEXT(self);

    return result;
  }

  method asText {
    context return: self
  }
}

#==============================================================================
# List Class

Object subClass: Listᶲ as: {

  constructor {
    return new meat::List(klass, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function get: index {
    try {
      return LIST(self).at(INTEGER(index) - 1);
    } catch (std::out_of_range &err) {
      throw meat::Exception("List index out of Range", context);
    }
    return null;
  }

  function set: index to: value {
    try {
      LIST(self).at(INTEGER(index) - 1) = value;
    } catch (std::out_of_range &err) {
      throw meat::Exception("Index out of Range", context);
    }
    return null;
  }

  function at: index insert: value {
    LIST(self).insert(LIST(self).begin() + (INTEGER(index) - 1), value);
    return null;
  }

  function remove: value {
    meat::List::iterator it = LIST(self).begin();
    while (it != LIST(self).end()) {
      if (*it == value)
        LIST(self).erase(it);
      it++;
    }

    return null;
  }

  function removeAt: index {
    LIST(self).erase(LIST(self).begin() + (INTEGER(index) - 1));
    return null;
  }

  function removeFrom: start to: end {
    LIST(self).erase(LIST(self).begin() + (INTEGER(start) - 1),
                     LIST(self).begin() + (INTEGER(end) - 1));
    return null;
  }

  function append: value {
    if (other->is_type(meat::Class::resolve("List"))) {
      LIST(self).insert(LIST(self).end(),
                        LIST(value).begin(),
                        LIST(value).end());
    } else {
      LIST(self).push_back(value);
    }

    return null;
  }

  function push: value {
    ((meat::List &)(*self)).push_back(value);
    return null;
  }

  function pop {
    LIST(self).pop_back();
    return null;
  }

  function isEmpty {
    return (LIST(self).empty() ? meat::True() : meat::False());
  }

  function swap: first with: second {
    try {
      meat::Reference temp = ((meat::List &)(*self)).at((int32_t)(*first) - 1);
      ((meat::List &)(*self)).at((int32_t)(*first) - 1) =
        ((meat::List &)(*self)).at((int32_t)(*second) - 1);
      ((meat::List &)(*self)).at((int32_t)(*second) - 1) = temp;
    } catch (std::out_of_range &err) {
      throw meat::Exception("Index out of Range", context);
    }

    return null;
  }

  function last {
    return LIST(self).back();
  }

  function clear {
    LIST(self).clear();
    return null;
  }

  function items {
    return new meat::Value((int32_t)(LIST(self).size()));
  }

  function forEach: item do: block {
    meat::uint16_t start_ip = meat::cast<meat::Context>(block).get_ip();
    meat::uint8_t local_id = (int32_t)(*item);

    meat::cast<meat::Context>(block).set_uplevel(context);

    meat::List::iterator it = ((meat::List &)(*self)).begin();
    for (; it != ((meat::List &)(*self)).end(); it++) {
      meat::cast<meat::Context>(block).set_local(local_id, *it);
      Reference result = execute(block);
      meat::cast<meat::Context>(block).set_ip(start_ip);
      meat::cast<meat::Context>(block).unfinish();

      if (result == "break") break;
    }

    return null;
  }

  function copy {
    Reference new_list = meat::List();
    LIST(new_list) = LIST(self);
    return new_list;
  }
}

#==============================================================================
# Set Class

Object subClass: Setᶲ as: {

  constructor {
    return new meat::Set(klass, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function remove: value {
    meat::List::iterator it = meat::cast<meat::List>(self).begin();
    while (it != meat::cast<meat::List>(self).end()) {
      if (*it == value)
        meat::cast<meat::List>(self).erase(it);
      it++;
    }

    return null;
  }

  function insert: value {
    meat::cast<meat::Set>(self).insert(value);
    return null;
  }

  function hasEntry: value {
    return meat::Boolean(meat::cast<meat::Set(self).find(value) != 
                         meat::cast<meat::Set(self).end());
  }

  function isEmpty {
    return (meat::cast<meat::Set(self).empty() 
            ? meat::True() : meat::False());
  }

  function swap: other {
    SET(self).swap(SET(other));
    return null;
  }

  function clear {
    SET(self).clear();
    return null;
  }

  function entries {
    return new meat::Value(SET(self).size());
  }

  function forEach: item do: block {
    meat::uint8_t local_id = INTEGER(item);

    meat::cast<meat::Context>(block).set_messenger(context);

    meat::List::iterator it = SET(self).begin();
    for (; it != SET(self).end(); it++) {
      meat::cast<meat::BlockContext>(block).set_local(local_id, *it);
      execute(block);

      if (meat::cast<meat::BlockContext>(block).break_called() or meat::cast<meat::Context>(block).is_done())
        break;

      meat::cast<meat::BlockContext>(block).reset();
    }
    meat::cast<meat::BlockContext>(block).reset();

    return null;
  }

  function copy {
    meat::Reference new_set = new meat::Set();
    SET(new_set) = SET(self);
    return new_set;
  }
}


#==============================================================================
# Index Class

Object subClass: Indexᶲ as: {

  constructor {
    return new meat::Index(cls, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function get: key {
    meat::Index::iterator it = INDEX(self).find(key);
    if (it == INDEX(self).end())
      throw meat::Exception("Invalid key in index");

    return *it;
  }

  function set: key to: value {
    INDEX(self)[key] = value;
    return null;
  }

  function has: key {
    if (INDEX(*self).find(key) != INDEX(self).end())
      return meat::True();
    return meat::False();
  }

  function remove: key {
    INDEX(self).erase(key);
    return null;
  }

  function entries {
    int32_t size = INDEX(*self).size();
    return new meat::Value(size);
  }

  function isEmpty {
    return (INDEX(self).empty() ? meat::True() : meat::False());
  }

  function copy {
    meat::Index *result = new meat::Index();
    *result = INDEX(self);
    return result;
  }
}

#==============================================================================
# Application Class

Object subClass: Applicationᶲ as: {

  class function parameters {
    return new meat::Object((meat::int32_t)arg_count());
  }

  class function parameter: index {
    meat::int32_t idx = (int32_t)(*index);

    if (idx > arg_count() or idx <= 0)
      throw meat::Exception("Parameter index out of range");

    const char **argv = args();
    return new meat::Object(argv[idx - 1]);
  }

  class function getEnviron: key {
#if defined(__WIN32__)
#  error("TODO Environment access")
#elif defined(__linux__)
    char *value = getenv(key->to_string());
    if (value != (char *)0)
      return new meat::Object(value);
    else
      return new meat::Object("");
#else
#  error("Don't know how to read the system environment")
#endif
  }

  class method entry {
    Exception throw: "Application class method entry must be overridden"
  }

  method entry {
    Exception throw: "Application method entry must be overridden"
  }
}

#==============================================================================
# Library Class

#Object subClass: Libraryᶲ as: {

#  class property newLibrary

#  property cppIncludes
#  property applicationClass
#  property imports
#  property classes

#  class function import: filename {
#ifdef DEBUG
#    std::cout << "DEBUG: Importing library " << filename->to_string()
#              << std::endl;
#endif /* DEBUG */

#    if (meat::data::compiler_import != 0)
#      meat::data::compiler_import(filename->to_string());
#    else {
#      meat::data::Library::import(filename->to_string());
#    }

#    return null;
#  }

  #class function include: cpp_includes {
  # if (meat::data::compiler_import != 0)
  #   meat::data::Library::include(cpp_includes->to_string());
  # else
  #   throw Exception("Method Library include is only with the compiler");
  #
  # return null;
  #}

#  class method include: includes {
#    [newLibrary isNull] isFalse: {
#      cppIncludes = includes
#    } else: {
#      Exception throw: "Library method include: can only be used with Grinder"
#    }
#  }

#  class function setApplication: class_name {
#    ((meat::data::Library &)(*self)).set_application(class_name->to_string());
#  }
#}
