# Sample template of the internal builtin classes
#
# Copyright (c) 2017 Ron R Wills <ron.rwsoft@gmail.com>
#
# This file is part of Meat.
#
# Meat is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Meat is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Meat.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
#   Since we need gitgo to compile this file, the 'ᶲ' character found in all
#  the class names is to prevent collisions with the builtin in classes. Once
#  the cpp file is generated then the ᶲ characters are stripped out.
#   The generate cpp file is still not valid because all the hash values are
#  included in the name hashing...

Library include: {
#include <meat/utilities.h>

#include <cstdlib>
#include <cstring>
#include <sstream>

#ifdef TESTING
#include <testing.h>
#endif /* TESTING */
}

#==============================================================================
# 3.1 Object Class
#

Object subclass: Objectᶲ as: {

  constructor {
    return new meat::Object(klass, properties);
  }

  # 3.1.1
  class method == other {
    context return: [self is: other]
  }

	# 3.1.2
  class method <> other {
    context return: [self isNot: other]
  }

	# 3.1.3
  class function is: other {
    return Boolean(self == other);
  }

	# 3.1.4
  class function isNot: other {
    return Boolean(not (self == other));
  }

	# 3.1.5
  class method isObject {
    context return: [Boolean false]
  }

	# 3.1.6
  class method isClass {
    context return: [Boolean true]
  }

	# 3.1.7
  class method isNull {
    context return: [Boolean false]
  }

	# 3.1.8
  class method type {
    context return: Class
  }

	# 3.1.9
	class method isType: type {
		context return: [Class == type]
	}

	# 3.1.10
  class function weakReference {
    return self.weak();
  }

	# 3.1.11
  class function normalReference {
    return self.normal();
  }

	# 3.1.12
  class function isWeakReference {
    return Boolean(self.is_weak());
  }

	# 3.1.13
  method initialize {
  }

	# 3.1.14
  method cleanup {
  }

	# 3.1.1
  method == other {
    context return: [self is: other]
  }

	# 3.1.2
  method <> other {
    context return: [self isNot: other]
  }

	# 3.1.3
  function is: other {
    return Boolean(self == other);
  }

	# 3.1.4
  function isNot: other {
    return Boolean(not (self == other));
  }

	# 3.1.5
  method isObject {
    context return: [Boolean true]
  }

	# 3.1.6
  method isClass {
    context return: [Boolean false]
  }

	# 3.1.8
  function type {
    return self->type();
  }

	# 3.1.9
  function isType: type {
    return Boolean(self->is_type(type));
  }

  method isNull {
    context return: [Boolean false]
  }

	# 3.1.10
  function weakReference {
    return self.weak();
  }

	# 3.1.11
  function normalReference {
    return self.normal();
  }

	# 3.1.12
  function isWeakReference {
    return Boolean(self.is_weak());
  }
}

#==============================================================================
# 3.2 Class Class

Object subclass: Classᶲ as: {

  class function newObject {
    Reference messenger = cast<Context>(context).get_messenger();

    // Create the new object and call the initialize method.
    Reference new_object = CLASS(self).new_object();
    Reference init_ctx = message(new_object, "initialize", context);
    execute(init_ctx);

    // We replace the self object to the new object.
    cast<Context>(messenger).reset_self(new_object);

    return null;
  }

  class function subclass: name as: block {
    if (grinder_impl() != NULL) {
      grinder_impl()->create_class(self, cast<Text>(name),
                                   cast<Text>(block), context);
    } else {
      throw Exception("No compiler implementation is loaded");
    }

    return null;
  }

  class function superClass {
    return cast<Class>(self).super();
  }

  class method initialize {
  }

  class function getName {
    return new Text(cast<Class>(self).get_name());
  }
}

#==============================================================================
# Context Class

Object subclass: Contextᶲ as: {

  constructor {
    return new meat::Context(properties);
  }

  class method subclass: name as: def {
    Exception throw: "Cannot subclass an internal Context class"
  }

  class method newObject {
    Exception throw: "Cannot create a new internal Context object" \
      for: [context uplevel]
  }

  function messenger {
    return cast<Context>(self).messenger();
  }

  function localVariables {
    return new meat::Value(cast<Context>(self).locals() - 4);
  }

  function getLocal: index {
    return cast<Context>(self).local(INTEGER(index));
  }

  function setLocal: index to: value {
    cast<Context>(self).local(INTEGER(index)) = value;
    return null;
  }

  function repeat: block {
    cast<Context>(block).messenger(context);

    for (;;) {
      cast<BlockContext>(block).set_break_trap();
      cast<BlockContext>(block).set_continue_trap();
      execute(block);

      if (cast<BlockContext>(block).break_called() or
          cast<Context>(block).is_done())
        break;

      cast<BlockContext>(block).reset();
    }
    cast<BlockContext>(block).reset();

    return null;
  }

  function return {
    cast<Context>(self).finish();
    return null;
  }

  function return: value {
    cast<Context>(self).result(value); // Set the return value
    cast<Context>(self).finish();      // Tell the context it's done.
    return null;
  }

  method break {
  }

  method continue {
  }
}

#==============================================================================
# BlockContext Class

Object subclass: BlockContextᶲ as: {

  function execute {
    cast<BlockContext>(self).messenger(context);
    execute(self);
    cast<BlockContext>(self).reset();

    return null;
  }

  function executeOnBreak: breakBlock {
    cast<BlockContext>(self).set_break_trap();
    cast<BlockContext>(self).messenger(context);
    execute(self);

    if (cast<BlockContext>(self).break_called()) {
      Reference up_context = message(breakBlock, "execute", context);
      execute(up_context);
    }

    cast<BlockContext>(self).reset();

    return null;
  }

  function executeOnBreak: breakBlock onContinue: continueBlock {
    cast<BlockContext>(self).set_break_trap();
    cast<BlockContext>(self).set_continue_trap();
    cast<BlockContext>(self).messenger(context);
    execute(self);

    if (cast<BlockContext>(self).break_called()) {
      Reference up_context = message(breakBlock, "execute", context);
      execute(up_context);
    } else if (meat::cast<meat::BlockContext>(self).continue_called()) {
      Reference up_context = message(continueBlock, "execute", context);
      execute(up_context);
    }

    cast<BlockContext>(self).reset();

    return null;
  }

  function executeOnContinue: continueBlock {
    cast<meat::BlockContext>(self).set_continue_trap();
    cast<meat::BlockContext>(self).messenger(context);
    execute(self);

    if (cast<BlockContext>(self).continue_called()) {
      Reference up_context = message(continueBlock, "execute", context);
      execute(up_context);
    }

    cast<BlockContext>(self).reset();

    return null;
  }

  function return {
    // We need to get the actual context to message the return method from.
    Reference origin = cast<BlockContext>(self).origin();
    Reference up_context = message(origin, "return", context);
    execute(up_context);

    cast<Context>(self).finish(); // Tell the context it's done.

    return null;
  }

  function return: value {
    Reference origin = cast<BlockContext>(self).origin();
    Reference up_context = message(origin, "return:", context);
    cast<Context>(up_context).parameter(0, value);
    execute(up_context);

    cast<Context>(self).finish(); // Tell the context it's done.

    return null;
  }

  function continue {
    cast<BlockContext>(self).c_continue();
    if (not meat::cast<meat::BlockContext>(self).continue_trap_set()) {
      Reference init_ctx = cast<BlockContext>(self).origin();
      Reference up_context = message(init_ctx, "continue", context);
      execute(up_context);
    }
    return null;
  }

  function break {
    cast<BlockContext>(self).c_break();
    if (not cast<BlockContext>(self).break_trap_set()) {
      Reference init_ctx = cast<BlockContext>(self).origin();
      Reference up_context = message(init_ctx, "break", context);
      execute(up_context);
    }
    return null;
  }
}

#==============================================================================
# Null Class
#
#  This class has only a single object to define null.

Object subclass: Nullᶲ as: {

  class property nullObject

  class method newObject {
    Exception throw: "Cannot create a new internal Null object" \
      for: [context messenger]
  }

  class method subclass: name as: block {
    Exception throw: "Cannot subclass an internal Null class" \
      for: [context messenger]
  }

  method object {
    context return: nullObject
  }

  method isNull {
    context return: [Boolean true]
  }
}

#==============================================================================
# Exception Class

Object subclass: Exceptionᶲ as: {

  property mesg
  property cntxt

  constructor {
    return new meat::Exception(klass, properties);
  }

  class function try: block {
    cast<Context>(block).messenger(context);

    try {
      execute(block);
    } catch (meat::Exception &err) {
    } catch (...) {
    }
    cast<BlockContext>(block).reset();

    return null;
  }

  class function try: try_block catch: catch_block {
    try {
      cast<meat::Context>(try_block).messenger(context);
      execute(try_block);
    } catch (std::exception &err) {
      cast<Context>(catch_block).messenger(context);
      execute(catch_block);
      cast<BlockContext>(catch_block).reset();
    }

    cast<BlockContext>(try_block).reset();

    return null;
  }

  class function try: try_block catch: error do: catch_block {
    try {
      cast<Context>(try_block).messenger(context);
      execute(try_block);
    } catch (Exception &err) {
      Reference excp = new meat::Exception(err);
      cast<Context>(catch_block).local(INTEGER(error)) = excp;
      cast<Context>(catch_block).messenger(context);
      execute(catch_block);
      cast<BlockContext>(catch_block).reset();
    }

    cast<BlockContext>(try_block).reset();

    return null;
  }

  class function throw {
    Reference ctx = cast<Context>(context).messenger();
    throw Exception(null, ctx);
  }

  class function throw: message {
    Reference ctx = cast<Context>(context).messenger();
    throw Exception(message, ctx);
  }

  class function throw: message for: ctx {
    throw Exception(message, ctx);
  }

  method message {
    context return: mesg
  }

  method context {
    context return: cntxt
  }
}

#==============================================================================
# Boolean Class

Object subclass: Booleanᶲ as: {

  class property trueObject
  class property falseObject

  class method true {
    context return: trueObject
  }

  class method false {
    context return: falseObject
  }

  function isTrue: block {
    if (self == trueObject) {
      cast<BlockContext>(block).messenger(context);
      execute(block);
      cast<BlockContext>(block).reset();
    }
    return null;
  }

  function isTrue: trueBlock else: elseBlock {
    if (self == trueObject) {
      cast<BlockContext>(trueBlock).messenger(context);
      execute(trueBlock);
      cast<BlockContext>(trueBlock).reset();
    } else {
      cast<BlockContext>(elseBlock).messenger(context);
      execute(elseBlock);
      cast<BlockContext>(elseBlock).reset();
    }
    return null;
  }

  function isFalse: block {
    if (self == falseObject) {
      cast<BlockContext>(block).messenger(context);
      execute(block);
      cast<BlockContext>(block).reset();
    }
    return null;
  }

  function isFalse: falseBlock else: elseBlock {
    if (self == falseObject) {
      cast<BlockContext>(falseBlock).messenger(context);
      execute(falseBlock);
      cast<BlockContext>(falseBlock).reset();
    } else {
      cast<BlockContext>(elseBlock).messenger(context);
      execute(elseBlock);
      cast<BlockContext>(elseBlock).reset();
    }
    return null;
  }

  method not {
    [self == trueObject] isTrue: {
      context return: falseObject
    } else: {
      context return: trueObject
    }
  }

  function or: other {
    return ((self == trueObject or other == trueObject) ?
            trueObject : falseObject);
  }

  function xor: other {
    return ((self == trueObject xor other == trueObject) ?
            trueObject : falseObject);
  }

  function and: other {
    return ((self == trueObject and other == trueObject) ?
            trueObject : falseObject);
  }

  method asText {
    [self == trueObject] isTrue: {
      context return: "true"
    } else: {
      context return: "false"
    }
  }
}

#==============================================================================
# Numeric

Object subclass: Numericᶲ as: {

  class method minValue {
    Exception throw: "Numeric value has no minimum value"
  }

  class method maxValue {
    Exception throw: "Numeric value has no minimum value"
  }

  method + other {
    Exception throw: "Method + undefined"
  }

  method - other {
    Exception throw: "Method - undefined"
  }

  method * other {
    Exception throw: "Method * undefined"
  }

  method / other {
    Exception throw: "Method / undefined"
  }

  method % other {
    Exception throw: "Method % undefined"
  }

  method ^ other {
    Exception throw: "Method ^ undefined"
  }

  method == other {
    Exception throw: "Method == undefined"
  }

  method <> other {
    Exception throw: "Method <> undefined"
  }

  method < other {
    Exception throw: "Method < undefined"
  }

  method <= other {
    Exception throw: "Method <= undefined"
  }

  method > other {
    Exception throw: "Method > undefined"
  }

  method >= other {
    Exception throw: "Method >= undefined"
  }

  method negative {
    Exception throw: "Method negative undefined"
  }

  method absolute {
    Exception throw: "Method absolute undefined"
  }

  method asText {
    Exception throw: "Unable to convert numeric value to Text"
  }
}

#==============================================================================
# Integer

Numeric subclass: Integerᶲ as: {

  constructor {
    return new meat::Value(klass, properties);
  }

  class function minValue {
    return new meat::Value(-2147483647-1);
  }

  class function maxValue {
    return new meat::Value(2147483647);
  }

  function + other {
    meat::uint32_t res;
    bool overflow = __builtin_add_overflow(INTEGER(self),
                                           INTEGER(other),
                                           &res);
    if (overflow)
      throw meat::Exception("Addition overflow");
    return new meat::Value(res);
  }

  function - other {
    return new meat::Value(INTEGER(self) - INTEGER(other));
  }

  function * other {
    return new meat::Value(INTEGER(self) * INTEGER(other));
  }

  function / other {
    return new meat::Value(INTEGER(self) / INTEGER(other));
  }

  function % other {
    return new meat::Value(INTEGER(self) % INTEGER(other));
  }

  function ^ other {
    return new meat::Value((meat::float_t)std::pow(FLOAT(self),
                                                   FLOAT(other)));
  }

  function == other {
    try {
      if (INTEGER(self) == INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <> other {
    try {
      if (INTEGER(self) != INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function < other {
    try {
      if (INTEGER(self) < INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <= other {
    try {
      if (INTEGER(self) <= INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function > other {
    try {
      if (INTEGER(self) > INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function >= other {
    try {
      if (INTEGER(self) >= INTEGER(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function negative {
    return new meat::Value(-INTEGER(self));
  }

  function absolute {
    return new meat::Value(std::abs(INTEGER(self)));
  }

  function or: other {
    return new meat::Value(INTEGER(self) | INTEGER(other));
  }

  function and: other {
    return new meat::Value(INTEGER(self) & INTEGER(other));
  }

  function xor: other {
    return new meat::Value(INTEGER(self) ^ INTEGER(other));
  }

  function rshift {
    return new meat::Value(INTEGER(self) >> 1);
  }

  function rshift: amount {
    return new meat::Value(INTEGER(self) >> INTEGER(amount));
  }

  function lshift {
    return new meat::Value(INTEGER(self) << 1);
  }

  function lshift: amount {
    return new meat::Value(INTEGER(self) << INTEGER(amount));
  }

  function timesDo: block {
    meat::int32_t limit = INTEGER(self);

    meat::cast<meat::BlockContext>(block).set_messenger(context);
    for (meat::int32_t c = 0; c < limit; c++) {
      meat::execute(block);
      meat::cast<meat::BlockContext>(block).reset();
    }

    return null;
  }

  function asText {
    std::stringstream result;
    result << INTEGER(self);
    return new meat::Text(result.str());
  }
}

#==============================================================================
# Number Class

Numeric subclass: Numberᶲ as: {

  constructor {
    return new meat::Value(klass, properties);
  }

  function + other {
    return new meat::Value(FLOAT(self) + FLOAT(other));
  }

  function - other {
    return new meat::Value(FLOAT(self) - FLOAT(other));
  }

  function * other {
    return new meat::Value(FLOAT(self) * FLOAT(other));
  }

  function / other {
    if (FLOAT(other) == 0.0)
      throw meat::Exception("Divide by zero");

    return new meat::Value(FLOAT(self) / FLOAT(other));
  }

  function % other {
    return new meat::Value(std::fmod(FLOAT(self), FLOAT(other)));
  }

  function ^ other {
    return new meat::Value((meat::float_t)std::pow(FLOAT(self),
                                                   FLOAT(other)));
  }

  function == other {
    try {
      if (FLOAT(self) == FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <> other {
    try {
      if (FLOAT(self) != FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function < other {
    try {
      if (FLOAT(self) < FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function <= other {
    try {
      if (FLOAT(self) <= FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function > other {
    try {
      if (FLOAT(self) > FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function >= other {
    try {
      if (FLOAT(self) >= FLOAT(other))
        return meat::BTrue();
    } catch (...) {}
    return meat::BFalse();
  }

  function negative {
    return new meat::Value(-FLOAT(self));
  }

  function absolute {
    return new meat::Value(std::abs(FLOAT(self)));
  }

  function asText {
    std::stringstream result;
    result << (double)FLOAT(self);
    return new meat::Text(result.str());
  }
}

#==============================================================================
# Text Class

Object subclass: Textᶲ as: {

  constructor {
    new meat::Text(klass, properties);
  }

	# 3.11.1
  function isEmpty {
    return Boolean(cast<Text>(self).empty());
  }

	# 3.11.2
  function length {
    std::int32_t length = 0;
    utf8::Iterator it(cast<const Text>(self));
    for (; it != it.end(); ++it, ++length);

    return new Value(length);
  }

	# 3.11.3
  function getCharAt: index {
    int i = INTEGER(index);

    if (i <= 0) throw Exception("Text character index out of range");

    utf8::Iterator it(cast<const Text>(self));
    for (; it != it.end() and i > 1; ++it, --i);

    if (it == it.end())
      throw Exception("Text character index out of range");

    return new Text(*it);
  }

	# 3.11.4
  function getFrom: start count: end {
    int start_idx = INTEGER(index);
    int end_count = INTEGER(end);

    // Make sure the starting index is in range.
    if (start_idx <= 0)
      throw Exception("Text character index out of range");

    utf8::Iterator it(cast<const Text>(self));
    for (; it != it.end() and start_idx > 1; ++it, --start_idx);

    if (it == it.end())
      throw Exception("Text character index out of range");

    utf8::Iterator start_it(it);

    for (; it != it.end() and end > 1; ++it, --end);

    return new Text(utf8::substr(start_it, it));
  }

	# 3.11.5
	function replaceFrom: start count: end with: value {
		int start_idx = INTEGER(start);
  	int end_count = INTEGER(end);

		// Make sure the starting index is in range.
    if (start_idx <= 0)
      throw Exception("Text character index out of range");

    utf8::Iterator it(cast<const Text>(self));
    for (; it != it.end() and start_idx > 1; ++it, --start_idx);

    if (it == it.end())
      throw Exception("Text character index out of range");

    utf8::Iterator start_it(it);

    for (; it != it.end() and end > 1; ++it, --end);

		return new Text(utf8::replace(start_it, it, cast<Text>(value)));
	}

	# 3.11.6
	function replaceAll: text with: value {
	  const std::string &tvalue = cast<const Text>(text);
		const std::string &vvalue = cast<const Text>(value);
	  std::string result = cast<Text>(self);

		size_t index = result.find(tvalue);
		while (index != std::string::npos) {
			result.replace(index, tvalue.length(), vvalue);
			index = result.find(tvalue, index + vvalue.length());
		}

		return new Text(result);
	}

	# 3.11.7
  function findFirst: value {
    std::int32_t index = 1;
    utf8::Iterator first_char(cast<const Text>(value));
    utf8::Iterator it(cast<const Text>(self));

    for (; it != it.end(); ++it, ++index) {
      if ((*it == *first_char) and
          (cast<Text>(self).compare(it.position(),
                                    cast<Text>(value).length(),
                                    cast<Text>(value)) == 0)) {
        return new Value(index);
      }
    }

    return new Value(0);
  }

	# 3.11.8
  function findFirst: value at: index {
		std::int32_t result = 1;
  	utf8::Iterator first_char(cast<const Text>(value));
  	utf8::Iterator it(cast<const Text>(self));

    int start_idx = INTEGER(index);

    // Make sure the starting index is in range.
    if (start_idx <= 0)
      throw Exception("Text character index out of range");

    for (; it != it.end() and start_idx > 1; ++it, --start_idx, ++result);

    if (it == it.end())
      throw Exception("Text character index out of range");

    for (; it != it.end(); ++it, ++result) {
      if ((*it == *first_char) and
          (cast<Text>(self).compare(it.position(),
                                    cast<Text>(value).length(),
                                    cast<Text>(value)) == 0)) {
        return new Value(result);
      }
    }

    return new Value(0);
  }

	# 3.11.9
  function findLast: value {
    return null;
  }

	# 3.11.10
	function findLast: value at: index {
	  return null;
	}

	# 3.11.11
  function forEach: character do: block {
    std::uint8_t local_id = INTEGER(character);
    cast<Context>(block).messenger(context);

    utf8::Iterator it(cast<const Text>(self));
    for (; it != it.end(); ++it) {
      cast<BlockContext>(block).set_break_trap();
      cast<Context>(block).local(local_id) = new Text(*it);
      execute(block);

      if (cast<BlockContext>(block).break_called()) break;
      else cast<BlockContext>(block).reset();
    }
    cast<BlockContext>(block).reset();

    return null;
  }

	# 3.11.12
	method asLowercase {
	  context return: self
	}

	# 3.11.13
	method asUppercase {
	  context return: self
	}

	# 3.11.14
	function copy {
    return new Text(cast<Text>(self));
  }

	# 3.11.15
	function asNumber {
	  return null;
	}

	# 3.11.16
	function asInteger {
	  return null;
	}

	# 3.11.17
	method asText {
    context return: self
  }

	# 3.11.18
  function == other {
    return Boolean(cast<Text>(self).compare(cast<Text>(other)) == 0);
  }

	# 3.11.19
  function <> other {
    return Boolean(cast<Text>(self).compare(cast<Text>(other)) != 0);
  }

	# 3.11.20
  function < other {
    return Boolean(cast<Text>(self).compare(cast<Text>(other)) < 0);
  }

	# 3.11.21
  function <= other {
    return Boolean(cast<Text>(self).compare(cast<Text>(other)) <= 0);
  }

	# 3.11.22
  function > other {
    return Boolean(cast<Text>(self).compare(cast<Text>(other)) > 0);
  }

	# 3.11.23
  function >= other {
    return Boolean(cast<Text>(self).compare(cast<Text>(other)) >= 0);
  }

	# 3.11.24
  function + other {
    return new Text(cast<Text>(self) + cast<Text>(other));
  }

	# 3.11.25
  function * count {
    std::int32_t cnt_value = INTEGER(count);
    Text *result = new Text();

    for (std::int_fast32_t c = 0; c < cnt_value; ++c)
      (*result) += cast<Text>(self);

    return result;
  }
}

#==============================================================================
# List Class

Object subclass: Listᶲ as: {

  constructor {
    return new meat::List(klass, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function get: index {
    try {
      return LIST(self).at(INTEGER(index) - 1);
    } catch (std::out_of_range &err) {
      throw meat::Exception("List index out of Range", context);
    }
    return null;
  }

  function set: index to: value {
    try {
      LIST(self).at(INTEGER(index) - 1) = value;
    } catch (std::out_of_range &err) {
      throw meat::Exception("Index out of Range", context);
    }
    return null;
  }

  function at: index insert: value {
    LIST(self).insert(LIST(self).begin() + (INTEGER(index) - 1), value);
    return null;
  }

  function remove: value {
    meat::List::iterator it = LIST(self).begin();
    while (it != LIST(self).end()) {
      if (*it == value)
        LIST(self).erase(it);
      it++;
    }

    return null;
  }

  function removeAt: index {
    LIST(self).erase(LIST(self).begin() + (INTEGER(index) - 1));
    return null;
  }

  function removeFrom: start to: end {
    LIST(self).erase(LIST(self).begin() + (INTEGER(start) - 1),
                     LIST(self).begin() + (INTEGER(end) - 1));
    return null;
  }

  function append: value {
    if (other->is_type(meat::Class::resolve("List"))) {
      LIST(self).insert(LIST(self).end(),
                        LIST(value).begin(),
                        LIST(value).end());
    } else {
      LIST(self).push_back(value);
    }

    return null;
  }

  function push: value {
    ((meat::List &)(*self)).push_back(value);
    return null;
  }

  function pop {
    LIST(self).pop_back();
    return null;
  }

  function isEmpty {
    return (LIST(self).empty() ? meat::True() : meat::False());
  }

  function swap: first with: second {
    try {
      meat::Reference temp = ((meat::List &)(*self)).at((int32_t)(*first) - 1);
      ((meat::List &)(*self)).at((int32_t)(*first) - 1) =
        ((meat::List &)(*self)).at((int32_t)(*second) - 1);
      ((meat::List &)(*self)).at((int32_t)(*second) - 1) = temp;
    } catch (std::out_of_range &err) {
      throw meat::Exception("Index out of Range", context);
    }

    return null;
  }

  function last {
    return LIST(self).back();
  }

  function clear {
    LIST(self).clear();
    return null;
  }

  function items {
    return new meat::Value((int32_t)(LIST(self).size()));
  }

  function forEach: item do: block {
    meat::uint16_t start_ip = meat::cast<meat::Context>(block).get_ip();
    meat::uint8_t local_id = (int32_t)(*item);

    meat::cast<meat::Context>(block).set_uplevel(context);

    meat::List::iterator it = ((meat::List &)(*self)).begin();
    for (; it != ((meat::List &)(*self)).end(); it++) {
      meat::cast<meat::Context>(block).set_local(local_id, *it);
      Reference result = execute(block);
      meat::cast<meat::Context>(block).set_ip(start_ip);
      meat::cast<meat::Context>(block).unfinish();

      if (result == "break") break;
    }

    return null;
  }

  function copy {
    Reference new_list = meat::List();
    LIST(new_list) = LIST(self);
    return new_list;
  }
}

#==============================================================================
# Set Class

Object subclass: Setᶲ as: {

  constructor {
    return new meat::Set(klass, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function remove: value {
    meat::List::iterator it = meat::cast<meat::List>(self).begin();
    while (it != meat::cast<meat::List>(self).end()) {
      if (*it == value)
        meat::cast<meat::List>(self).erase(it);
      it++;
    }

    return null;
  }

  function insert: value {
    meat::cast<meat::Set>(self).insert(value);
    return null;
  }

  function hasEntry: value {
    return meat::Boolean(meat::cast<meat::Set(self).find(value) !=
                         meat::cast<meat::Set(self).end());
  }

  function isEmpty {
    return (meat::cast<meat::Set(self).empty()
            ? meat::True() : meat::False());
  }

  function swap: other {
    SET(self).swap(SET(other));
    return null;
  }

  function clear {
    SET(self).clear();
    return null;
  }

  function entries {
    return new meat::Value(SET(self).size());
  }

  function forEach: item do: block {
    meat::uint8_t local_id = INTEGER(item);

    meat::cast<meat::Context>(block).set_messenger(context);

    meat::List::iterator it = SET(self).begin();
    for (; it != SET(self).end(); it++) {
      meat::cast<meat::BlockContext>(block).set_local(local_id, *it);
      execute(block);

      if (meat::cast<meat::BlockContext>(block).break_called() or meat::cast<meat::Context>(block).is_done())
        break;

      meat::cast<meat::BlockContext>(block).reset();
    }
    meat::cast<meat::BlockContext>(block).reset();

    return null;
  }

  function copy {
    meat::Reference new_set = new meat::Set();
    SET(new_set) = SET(self);
    return new_set;
  }
}


#==============================================================================
# Index Class

Object subclass: Indexᶲ as: {

  constructor {
    return new meat::Index(cls, properties);
  }

  class method new {
    self newObject
    context return: self
  }

  function get: key {
    meat::Index::iterator it = INDEX(self).find(key);
    if (it == INDEX(self).end())
      throw meat::Exception("Invalid key in index");

    return *it;
  }

  function set: key to: value {
    INDEX(self)[key] = value;
    return null;
  }

  function has: key {
    if (INDEX(*self).find(key) != INDEX(self).end())
      return meat::True();
    return meat::False();
  }

  function remove: key {
    INDEX(self).erase(key);
    return null;
  }

  function entries {
    int32_t size = INDEX(*self).size();
    return new meat::Value(size);
  }

  function isEmpty {
    return (INDEX(self).empty() ? meat::True() : meat::False());
  }

  function copy {
    meat::Index *result = new meat::Index();
    *result = INDEX(self);
    return result;
  }
}

#==============================================================================
# Application Class

Object subclass: Applicationᶲ as: {

  class function parameters {
    return new meat::Object((meat::int32_t)arg_count());
  }

  class function parameter: index {
    meat::int32_t idx = (int32_t)(*index);

    if (idx > arg_count() or idx <= 0)
      throw meat::Exception("Parameter index out of range");

    const char **argv = args();
    return new meat::Object(argv[idx - 1]);
  }

  class function getEnviron: key {
#if defined(__WIN32__)
#  error("TODO Environment access")
#elif defined(__linux__)
    char *value = getenv(key->to_string());
    if (value != (char *)0)
      return new meat::Object(value);
    else
      return new meat::Object("");
#else
#  error("Don't know how to read the system environment")
#endif
  }

  class method entry {
    Exception throw: "Application class method entry must be overridden"
  }

  method entry {
    Exception throw: "Application method entry must be overridden"
  }
}

#==============================================================================
# Library Class

#Object subclass: Libraryᶲ as: {

#  class property newLibrary

#  property cppIncludes
#  property applicationClass
#  property imports
#  property classes

#  class function import: filename {
#ifdef DEBUG
#    std::cout << "DEBUG: Importing library " << filename->to_string()
#              << std::endl;
#endif /* DEBUG */

#    if (meat::data::compiler_import != 0)
#      meat::data::compiler_import(filename->to_string());
#    else {
#      meat::data::Library::import(filename->to_string());
#    }

#    return null;
#  }

  #class function include: cpp_includes {
  # if (meat::data::compiler_import != 0)
  #   meat::data::Library::include(cpp_includes->to_string());
  # else
  #   throw Exception("Method Library include is only with the compiler");
  #
  # return null;
  #}

#  class method include: includes {
#    [newLibrary isNull] isFalse: {
#      cppIncludes = includes
#    } else: {
#      Exception throw: "Library method include: can only be used with Grinder"
#    }
#  }

#  class function setApplication: class_name {
#    ((meat::data::Library &)(*self)).set_application(class_name->to_string());
#  }
#}
