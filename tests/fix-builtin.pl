#! /usr/bin/perl -w
#
# Copyright (c) 2018 Ron R Wills <ron.rwsoft@gmail.com>
#
# This file is part of Meat.
#
# Meat is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Meat is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Meat.  If not, see <http://www.gnu.org/licenses/>.
#
#==============================================================================
#
#  I'm not a fan of Perl but this is what Perl does best. When a class is
# loaded in the Meat virtual machine, meat doesn't allow the class to be
# replaced. Therefore, we can't use Grinder to create the builtin classes.
# Because of this we play some games. We add the ᶲ unicode character to the
# names to avoid class name collisions, but this makes the c++ code generated
# incorrect. This is where this script comes in ;)
#
#  To create the src/builtin.cpp file completely by hand would be a absolute
# nightmare so we want Grinder to do it. What we get from builtin.meat isn't
# quite usable and takes some work to make it usable. This script does that
# work for us and lets us maintain the code in the builtin.meat file.
#
# $ cp ../src/builtin.cpp ../src/builtin.cpp.bak
# $ make test
# $ ./fix-builtin.pl builtin.cpp > ../src/builtin.cpp
#
#  Now build the software. If it doesn't build the differences can be checked
# between the backup and the newly generated file.
#
# *** DON'T MAKE THE ASSUMTION THIS SCRIPT WORKS 100% OF THE TIME ***
# ***         MAKE BACKUPS AND DOUBLE CHECK THE RESULTS           ***

%hash_trans = ();
$lib_add = "";

sub translate_hashes {
		foreach $name (@_) {
				# Get the hash value that will be found in the code.
				open(GRINDER_FH, "../bin/meat-grinder -# $nameᶲ |");
				local $old_hash = <GRINDER_FH>;
				chomp $old_hash;
				close(GRINDER_FH);

				# Get the new hash value we need in the code.
				open(GRINDER_FH, "../bin/meat-grinder -# $name |");
				local $new_hash = <GRINDER_FH>;
				chomp $new_hash;
				close(GRINDER_FH);

				$hash_trans{$old_hash} = $new_hash;
		}
}

sub translate_def {
		my ($name) = @_;
		foreach $name (@_) {
				local $name_lc = lc($name);

				#  To me, this seems a bit flaky but it works. Any little change in
				# the c++ generation will brake this. If any perl regex pros want
				# to take a wack at this, I'm willing to accept something more
				# robust ;)
				local $old_def = "(  cls = new meat::Class\\(meat::Class::resolve\\(0x[0-9a-f]+\\), \\d+, \\d+\\);(\n  cls->set_constructor\\(\Q$name\E_constructor\\);)?(\n  cls->set_vtable\\(\\d+, \Q$name\EMethods, meat::STATIC\\);)?(\n  cls->set_class_vtable\\(\\d+, \Q$name\ECMethods, meat::STATIC\\);)?(\n  cls->bytecode\\(\\d+, \Q$name\EBytecode, meat::STATIC\\);)?
  library.add\\(cls, \"$name\"\\);)";

				#  If it is matched then fix the code, otherwise it's better to leave
				# the original untouched and modify it by hand.
				if ($cpp =~ /$old_def/mg) {
						local $new_def = "$1";
						$new_def =~ s/  cls =/  Class *\Q$name_lc\E_cls =/g;
						$new_def =~ s/  cls->/  \Q$name_lc\E_cls->/g;
						$new_def =~ s/library.add\(cls, "$name"\);/Class::record(\Q$name_lc\E_cls, "$name");/g;

						$lib_add .= "  library->add(\Q$name_lc\E_cls, \"$name\");\n";

						$cpp =~ s/$old_def/$new_def/mg
				}
    }
}

###############################################################################
#  Get all the class name hashes with and without the ᶲ unicode character in
# the name.

translate_hashes("Object", "Class", "Context", "BlockContext", "Null",
                 "Exception", "Boolean", "Numeric", "Integer", "Number",
                 "Text", "List", "Set", "Index", "Archive", "Library",
                 "Application");

###############################################################################
#  Remove the ᶲ unicode character in the names and fix all the class name
# hashes in the virtual tables.

local $/;
$cpp = <>;

$cpp =~ s/ᶲ//g;

while (($key, $value) = each(%hash_trans)) {
		$cpp =~ s/$key/$value/g;
}

###############################################################################
# Replace the header with the GPL header.

$header = '\/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
 \* Auto-generated by the Grinder Compiler Library
 \*\/';

$gpl = '/*                                                                  -*- c++ -*-
 * The Meat language builtin classes.
 *
 * Copyright (c) 2017 Ron R Wills <ron.rwsoft@gmail.com>
 *
 * This file is part of Meat.
 *
 * Meat is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Meat is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Meat.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This file should not be modified directly. It is generated from the
 * builtin.meat found in the tests directory. Make any modification to the
 * tests/builtin.meat file, do a make test and use the tests/fix-builtin.pl
 * script to regenerate this file.
 *
 * This might seem like a chore but it sure beats maintaining this code by
 * hand ;)
 */';

$cpp =~ s/$header/$gpl/mg;

###############################################################################
#  Replace the library loading function definition with the meat::initialize
# function definition.

$old ='\/\/ We need to declare init_builtin as a C function.
extern "C" \{
  DECLSPEC void init_builtin\(meat::data::Library &library\);
\}

void init_builtin\(meat::data::Library &library\) \{
  meat::Class \*cls;';

$new = '/******************************************************************************
 * Public API
 */

void meat::initialize(int argc, const char *argv[]) {
  arg_count(argc);
  args(argv);';

$cpp =~ s/$old/$new/g;

###############################################################################
#  This modifies the actual creation of the object in the initialization
# function.

translate_def("Object", "Class", "Context", "BlockContext", "Null",
              "Exception", "Boolean", "Numeric", "Integer", "Number",
              "Text", "List", "Set", "Index", "Archive", "Library",
              "Application");

###############################################################################
# Required custom code.

# Initial setup for the Object and Class classes.

$cpp =~ s/Class \*class_cls = new meat::Class\(meat::Class::resolve\(0x[0-9a-f]+\), \d+, \d+\);/Class *class_cls = new Class(Null());/g;

$cpp =~ s/Class \*object_cls = new meat::Class\(meat::Class::resolve\(0x[0-9a-f]+\), \d+, \d+\);/Class *object_cls = new Class(\"Class\");/g;

$cpp =~ s/(Class \*blockcontext_cls = new meat::Class\(meat::Class::resolve\()0x[0-9a-f]+(\), \d+, \d+\);)/${1}0x1befcdac$2/g;

$new_code = "Class::record(object_cls, \"Object\");

  /*  When the first two class were created the ClassClass reference was null.
   * So here we finish the initialization of the Object and Class classes.
   */
  object_cls->_type = Class::resolve(\"Class\");
  class_cls->_type = Class::resolve(\"Class\").weak();";

$cpp =~ s/Class::record\(object_cls, "Object"\);/$new_code/g;

# Create the Null object.

$new_code = "Class::record(null_cls, \"Null\");
  null_cls->property(0) = new Object(Class::resolve(\"Null\"));";

$cpp =~ s/Class::record\(null_cls, "Null"\);/$new_code/g;

# Create the true and false objects.

$new_code = "Class::record(boolean_cls, \"Boolean\");
  boolean_cls->property(0) = new Value(true);
  boolean_cls->property(1) = new Value(false);";

$cpp =~ s/Class::record\(boolean_cls, "Boolean"\);/$new_code/g;

# Initialize the Library class properties.

$new_code = "Class::record(library_cls, \"Library\");
  library_cls->property(0) = new Index;
  library_cls->property(1) = new List;";

$cpp =~ s/Class::record\(library_cls, "Library"\);/$new_code/g;

# Actually build the __builtin__ library.

$new_code = "data::Library::add_path(\"\");

#if defined(__WIN32__)
  meat::data::Library::add_path(\"C:\\\\meat\\\\\");
#elif defined(__linux__)
  meat::data::Library::add_path(\"/usr/lib/meat/\");
#endif

  data::Library *library = new data::Library(\"__builtin__\");
$lib_add
  library->set_symbols(Symbols, meat::STATIC);
	__builtin__library() = library;";

$cpp =~ s/library.set_symbols\(Symbols, meat::STATIC\);/$new_code/g;

###############################################################################
# Dump the results...

print $cpp;
