# Sample template of the grinder compiler classes.
#
# Copyright (c) 2017 Ron R Wills <ron.rwsoft@gmail.com>
#
# This file is part of Meat.
#
# Meat is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Meat is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Meat.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
#   Since we need gitgo to compile this file, the 'ᶲ' character found in all
#  the class names is to prevent collisions with the builtin in classes. Once
#  the cpp file is generated then the ᶲ characters are stripped out.
#   The generate cpp file is still not valid because all the hash values are
#  included in the name hashing...

Library include: {
#include "compiler.h"
}

#==============================================================================
# Grinder.Library Class

Object subclass: Grinder.Libraryᶲ as: {

  property _name
  property classes
  property applicationClass
  property requiredLibraries
  property cppInclude

  constructor {
    return new meat::grinder::Library(klass, properties);
  }

  method initialize {
    super initialize

    classes = [List new]
    requiredLibraries = [Set new]
  }

  # Create a new Library Object with the given name.
  class function new: libraryName {
    Reference new_object = cast<meat::Class>(self).new_object();

    cast<grinder::Library>(new_object).property(0) = libraryName;
    cast<grinder::Library>(new_object).register_as(cast<Text>(libraryName));

    return new_object;
  }

  method import: libraryName {
    Library import: libraryName
    requiredLibraries append: libraryName
  }

  method removeImport: libraryName {
    requiredLibraries remove: libraryName
  }

  method getImportList {
    context return: [requiredLibraries copy]
  }

  # Return the name of the Library.
  method getName {
    context return: _name
  }

  method renameTo: newName {
    Exception throw: 'Currently unable to rename libraries.'
    _name = [newName asText]
  }

  function addClass: theClass {
    meat::cast<meat::grinder::Library>(self).add_class(theClass);
    return null;
  }

  method getClass: className {
    classes forEach: .cls do: {
      [className == [.cls getName]] isTrue: {
        context return: .cls
      }
    }
    Exception throw: [[['Class ' + className] + \
                       ' was not found in library '] + _name]
  }

  method getClassList {
    context return: [classes copy]
  }

  # XXX This isn't going to work. We need to unregister the class from the
  #     system as well.
  method removeClass: className {
    theClass = [self getClass: className]
    classes remove: theClass
  }

  method setApplicationClass: theClass {
    applicationClass = theClass
  }

  function compile {
    meat::cast<meat::grinder::Library>(self).write();
    return null;
  }
}

#==============================================================================
# Grinder.Class Class

Object subclass: Grinder.Classᶲ as: {

  property className
  property superClass
  property objectProperties
  property classProperties
  property objectMethods
  property classMethods
  property constr

  constructor {
    return new meat::grinder::Class(klass, properties);
  }

  method initialize {
    super initialize

    objectProperties = [Set new]
    classProperties = [Set new]

    objectMethods = [Index new]
    classMethods = [Index new]
  }

  class method from: aClass subclass: name {
    self newObject
    className = name
    superClass = [aClass getName]
    context return: self
  }

  method getName {
    context return: className
  }

  method getSuperName {
    context return: superClass
  }

  method addProperty: propertyName {
    objectProperties push: [propertyName asText]
  }

  method getPropertiesList {
    context return: [objectProperties copy]
  }

  method addClassProperty: propertyName {
    classProperties push: [propertyName asText]
  }

  method getClassPropertiesList {
    context return: [classProperties copy]
  }

  function addMethod: theMethod {
    if (theMethod->is_type("Grinder.Method")) {
      add_method(theMethod);
    } else {
      throw Exception("Attempting to add a non Grinder.Method to a "
                      "Grinder.Class");
    }
    return null;
  }

  method getMethodList {
    context return: [objectMethods copy]
  }

  method removeMethod: methodName {
    objectMethods remove: methodName
  }

  function addClassMethod: theMethod {
    if (theMethod->is_type("Grinder.Method")) {
      add_method(theMethod);
    } else {
      throw Exception("Attempting to add a non Grinder.Method to a "
                      "Grinder.Class");
    }
    return null;
  }

  method getClassMethodList {
    context return: [classMethods copy]
  }

  method removeClassMethod: methodName {
    classMethods remove: methodName
  }
}

#==============================================================================
# Grinder.Method Class

Object subclass: Grinder.Methodᶲ as: {

  property methodName
  property parameters
  property body

  constructor {
    return new meat::grinder::Method(klass, properties);
  }

  method initialize {
    super initialize
    parameters = [List new]
  }

  class method new: name {
    self newObject
    methodName = name
    context return: self
  }

  method getName {
    context return: methodName
  }

  method addParameter: name {
    parameters push: [name asText]
  }

  method removeParameter: name {
    parameters remove: [name asText]
  }

  method getParameterList {
    context return: [parameters copy]
  }

  method getBody {
    context return: body
  }

  method setBody: newBody {
    body = [newBody asText]
  }

  function isNative {
    if (meat::cast<meat::grinder::Method>(*self).is_cpp())
      return meat::True();
    return meat::False();
  }

  function isNative: value {
    if (value == meat::True())
      meat::cast<meat::grinder::Method>(self).is_cpp(true);
    else if (value == meat::False())
      meat::cast<meat::grinder::Method>(self).is_cpp(false);
    else
      throw meat::Exception("Grinder.Method isNative value is not a boolean");
  }
}
