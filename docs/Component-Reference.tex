\subsection {Byte Interpretation}

\subsubsection{Integer Values}

\begin{center}
  \begin{tabular}{ r | c r r }
    & Size (bits) & Original Value & Endian Swapped Value\\ \hline
    Byte & 8 & $12_{16}$ & $12_{16}$ \\
    Word & 16 & $1234_{16}$ & $3412_{16}$ \\
    Integer & 32 & $12345678_{16}$ & $56781234_{16}$ \\
    Long & 64 & $\mathrm{123456789ABCDEF0}_{16}$ & \\
  \end{tabular}
\end{center}

\subsection{Virtual Machine Bytecode}

\begin{center}
  \begin{tabular}{ | p{6cm} | c | p{8cm} | }
    \hline
    Operation & Code & Brief Description \\ \hline
    No Operation & $00_{16}$ & Only increament the bytecode pointer by one.
                              Nothing else is done. \\
    Message Object & $01_{16}$ & Send a message to an object. \\
    Message Object with Result & $02_{16}$ & Send a message to the object
                                            and assigning the result to a
                                            local variable. \\
    Message Object's Super Class & $03_{16}$ & Nothing is \\
    Message Object's Super Class with Result & $04_{16}$ & Nothing is \\
    Beginning of Block Context & $\mathrm{0A}_{16}$ & Nothing is \\
    End of Context & $\mathrm{0B}_{16}$ & Nothing is \\
    Assign Local Variable & $10_{16}$ & ...\\
    Assign Object Property & $11_{16}$ & ...\\
    Assign Class Property & $12_{16}$ & ...\\
    Assign Class to Local Variable & $13_{16}$ & ...\\
    Assign an Integer Constant to a Local Variable & $14_{16}$ & ...\\
    \hline
  \end{tabular}
\end{center}

\subsection{Library File Format}

\begin{center}
  \begin{tabular}{ |l|l|p{8cm}| }
    \hline
    \multirow{5}{*}{Header} & \texttt{unsigned bytes [4]} = ''MLIB'' & The
    magic file identifier\\ \cline{2-3}
    & \texttt{unsigned byte} = 1 & Major Meat library format version\\
    \cline{2-3}
    & \texttt{unsigned byte} = 0 & Minor Meat library format version\\
    \cline{2-3}
    & \texttt{unsigned word} = 0 & Reserved for future flags.\\ \cline{2-3}
    & \texttt{unsigned integer} = 0 & A hash ID for an application class for
    the virtual interpreter to message if the library is being executed.
    If this field is set to zero, then the library is not considered an
    executable application, but can still be loaded as a library.

    The hash ID must refer to an Application class within the same library.
    Any other reference is considered invalid and an Exception must be
    thrown to indicate the error by the virtual interpreter.\\
    \hline

    \multirow{2}{*}{Library Imports} & \texttt{unsigned byte} & The total number of libraries that need to be imported.\\ \cline{2-3}
    & \texttt{unsigned byte arrays} & A list of ''0'' terminated strings of each library name to be imported.\\ \hline

    \multirow{2}{*}{Serialized Class Objects} & \texttt{unsigned byte} & The total number of Classes serialized in the library.\\ \cline{2-3}
    & \texttt{serialized class array} & An array of all the serialized classes. see \hyperref[sec:class_serial]{Class Serialization}.\\ \hline
  \end{tabular}
\end{center}

\subsubsection{Class Serialization}
\label{sec:class_serial}

\textbf{Serialized Class Format}
\begin{center}
  \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \multirow{3}{*}{Header} & \texttt{unsigned integer} & The hashed ID of the class name.\\ \cline{2-3}
    & \texttt{unsigned byte} & The number of class properties.\\ \cline{2-3}
    & \texttt{unsigned byte} & The number of object properties.\\ \hline

    \multirow{2}{*}{Virtual Table} & \texttt{unsigned byte} & The number of virtual table entries.\\ \cline{2-3}
    & \texttt{unsigned byte} & The number of class virtual table entries.\\ \hline

    \multirow{2}{*}{Byte Code} & \texttt{unsigned word} & Size of the byte code array.\\ \cline{2-3}
    & \texttt{unsigned byte array} & The byte code.\\ \hline
  \end{tabular}
\end{center}

\textbf{Virtual Table Entries}
\begin{center}
  \begin{tabular}{|l|p{8cm}|}
    \hline
    \texttt{unsigned integer} & Hashed ID of the method name.\\ \hline
    \texttt{unsigned integer} & Hashed ID of the class where the method is found.\\ \hline
    \texttt{unsigned byte} & Entry flags.\\ \hline
    \texttt{unsigned byte} & The number of local variables required during execution.\\ \hline
    \texttt{unsigned word} & Byte code offset to the start of the method.\\ \hline
  \end{tabular}
\end{center}

\textbf{Virtual Table Entry Flags}
\begin{displaymath}
  \xymatrix @-1pc {Bit &*+[F]{7} \ar @{-} [ddd]&*+[F]{6} \ar @{-} [dd] &*+[F]{5} \ar @{-} [dd] &*+[F]{4} \ar @{-} [dd] &*+[F]{3} \ar @{-} [dd] &*+[F]{2} \ar @{-} [dd]
    &*+[F]{1} \ar @{-} [dd] &*+[F]{0} \ar @{-} [d] & \\
    & & & & & & & & \ar [r] & \txt<6cm>{If set the virtual table entry is an offset into the byte code, otherwise it is an internal function pointer.}\\
    & & \ar [rrrrrrr] & & & & & & & \txt<6cm>{Reserved for future use.}\\
    & \ar [rrrrrrrr] & & & & & & & & \txt<6cm>{Method found in a super class.}}
\end{displaymath}
